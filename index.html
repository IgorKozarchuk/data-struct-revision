<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Data Structures</title>
		<style>
			body, a {
				font-family: "Source Code Pro", monospace;
				font-size: 16px;
				background-color: #222;
				color: #2083FC;
			}
			h1 {
				text-align: center;
				padding-top: 4%;
				padding-bottom: 2%;
			}
			h3 {
				text-decoration: underline;
			}
			a {
				text-decoration: none;
			}
			a:hover {
				text-decoration: underline;
			}
			code {
				font-family: "Source Code Pro", monospace;
				white-space: pre;
			}
			#contents {
				padding: 0 5% 4% 10%;
			}
		</style>
	</head>
	<body>
		
		<h1>* Data Structures revision *</h1>

		<div id="contents">
			<h2>Contents</h2>
			<ol>
				<li><a href="#array">Array</a></li>
				<li><a href="#list">Linked List</a></li>
				<li><a href="#queue">Queue</a></li>
				<li><a href="#stack">Stack</a></li>
			</ol>
		</div>

		<h3 id="array">1. Array</h3>
		<p><b>Idea:</b> An array is a composite data type - it can store multiple values, and so is in the collection category. The stored values are called elements and are accessed by a sequence of indices.<br>
		The implementation of arrays is based on setting the bounds of indices of the array, the size of the array, normally by allocating a contiguous region of memory to hold the elements of the array, and using simple offset calculations on the indices from the origin of the memory to access memory elements.<br>
		Common operations defined on arrays include: 1) indexing (accessing an array element by its indices); 2) slicing (producing a subarray by putting some constraint on the indices); 3) iteration over the array's elements.<br>
		Access is O(1), appending is O(1), and insertion is O(n) for a single item.
		</p>

		<h3 id="list">2. Linked List</h3>
		<p><b>Idea:</b> A linked list is a collection of nodes that form linear sequence. Each node contains data and reference (link) to another nodes.<br>
		Linked lists have a "head" (the first node in the list) and sometimes a "tail" (the last node).<br>
		A <b>singly-linked list</b> allows traversal in one direction - forward. Each node contains a link to the next node. The last node points to null. Singly-linked list has O(1) insertion time [insertion itself is O(1), but node finding is O(n)] and O(n) removal time.<br>
		A <b>doubly-linked list</b> allows traversal in two directions - forward and back. Each node contains links to both the previous and next nodes. Doubly-linked list has O(1) removal and insertion times.</p>
<code>
	/* Singly-linked list */
	
	// node of the list
	function Node(data) {
		this.data = data; // node's data
		this.next = null; // pointer (link) to the next node
	}
	// singly-linked list
	function SLList() {
		this.head = new Node("head");
		this.append = append;
		this.prepend = prepend;
		this.insertAfter = insertAfter;
		this.insertBefore = insertBefore;
		this.remove = remove;
		this.print = print;
		// helper functions
		this.find = find;
		this.findPrev = findPrev;
	}

	// find node with data == item
	function find(item) {
		var current = this.head;
		while (current.data != item) {
			current = current.next;
		}
		return current;
	}
	// find previous node to node with data == item
	function findPrev(item) {
		var current = this.head;
		while (current.next.data != item) {
			current = current.next;
		}
		return current;
	}
	// add element to the end
	function append(element) {
		var newEnd = new Node(element);
		// find last
		var current = this.head;
		while (current.next != null) {
			current = current.next;
		}
		current.next = newEnd;
	}
	// add element to the beginning
	function prepend(element) {
		var newHead = new Node(element);
		newHead.next = this.head.next;
		this.head.next = newHead;
	}
	// insert element after specific item
	function insertAfter(element, item) {
		var newNode = new Node(element);
		var current = this.find(item);
		newNode.next = current.next;
		current.next = newNode;
	}
	// insert element before specific item
	function insertBefore(element, item) {
		var newNode = new Node(element);
		var current = this.findPrev(item);
		newNode.next = current.next;
		current.next = newNode;
	}
	// remove node with data == item
	function remove(item) {
		var current = this.findPrev(item);
		// link prev node to the node after item
		if (current.next != null) {
			current.next = current.next.next;
		}
	}
	// print list
	function print() {
		var current = this.head;
		while (current.next != null) {
			console.log(current.next.data);
			current = current.next;
		}
	}
</code>

		<h3 id="queue">3. Queue</h3>
		<p><b>Idea:</b> A queue is a linear FIFO (First-In-First-Out) data structure. That is, elements are added (enqueued) at one side and removed (dequeued) from the other in the order of insertion. <br>
		Space and search complexity is O(n), insertion/deletion is O(1).</p>
<code>
	// Queue implementation using circular array
	// next index in circular array of size N is (i+1)%N
	// thus for i=N-1 next index is N%N=0
	// prev index is (i+N-1)%N
	// https://www.youtube.com/watch?v=okr-XE8yTO8
	function Queue(size = 10) {
		this.SIZE = size;
		this.data = new Array(this.SIZE);
		// -1 represents invalid index of an empty queue
		this.front = -1; // front element index
		this.rear = -1; // rear element index
		this.isEmpty = isEmpty;
		this.isFull = isFull;
		this.enqueue = enqueue;
		this.dequeue = dequeue;
		this.head = head;
		this.print = print;
	}
	// check if queue is epmty
	function isEmpty() {
		// if front == -1, queue is empty
		return this.front == -1;
	}
	// check if queue is full
	function isFull() {
		return ((this.rear+1)%this.SIZE == this.front);
	}
	// add element to tail
	function enqueue(element) {
		if (this.isFull()) {
			console.log("Error: Queue is full");
			return;
		}
		if (this.isEmpty()) {
			this.front = 0;
			this.rear = 0;
		} else {
			this.rear = (this.rear+1)%this.SIZE;
		}
		this.data[this.rear] = element;
	}
	// remove element from head
	function dequeue() {
		if (this.isEmpty()) {
			console.log("Error: Queue is empty");
			return;
		}
		else if (this.front == this.rear) { // queue becomes empty
			this.front = -1;
			this.rear = -1;
		} else {
			this.front = (this.front+1)%this.SIZE;
		}
	}
	// return head element
	function head() {
		if (this.isEmpty()) {
			console.log("Error: Queue is empty");
			return;
		}
		return this.data[this.front];
	}
	// print queue
	function print() {
		if (this.isEmpty()) return;

		var i = this.front;
		while (i <= this.rear) {
			console.log(this.data[i]);
			i++;
		}
	}
</code>

		<h3 id="stack">4. Stack</h3>
		<p><b>Idea:</b> </p>
<code>
	
</code>
		
		<script>
			
		</script>

	</body>
</html>